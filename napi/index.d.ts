/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class BlsPair {
  constructor(seed: bigint)
  get sk(): SecretKey
  get pk(): PublicKey
}

export declare class BlsPairWithCoin {
  get sk(): SecretKey
  get pk(): PublicKey
  get puzzleHash(): Uint8Array
  get coin(): Coin
}

export declare class Clvm {
  constructor()
  alloc(value: any): Program
  nil(): Program
  pair(first: any, rest: any): Program
  deserialize(value: Uint8Array): Program
  deserializeWithBackrefs(value: Uint8Array): Program
  insertCoinSpend(coinSpend: CoinSpend): void
  coinSpends(): Array<CoinSpend>
  spendCoin(coin: Coin, spend: Spend): void
  delegatedSpend(conditions: Array<Program>): Spend
  standardSpend(syntheticKey: PublicKey, delegatedSpend: Spend): Spend
  spendStandardCoin(coin: Coin, syntheticKey: PublicKey, delegatedSpend: Spend): void
  spendCatCoins(cats: Array<CatSpend>): void
  remark(rest: Program): Program
  aggSigParent(publicKey: PublicKey, message: Uint8Array): Program
  aggSigPuzzle(publicKey: PublicKey, message: Uint8Array): Program
  aggSigAmount(publicKey: PublicKey, message: Uint8Array): Program
  aggSigPuzzleAmount(publicKey: PublicKey, message: Uint8Array): Program
  aggSigParentAmount(publicKey: PublicKey, message: Uint8Array): Program
  aggSigParentPuzzle(publicKey: PublicKey, message: Uint8Array): Program
  aggSigUnsafe(publicKey: PublicKey, message: Uint8Array): Program
  aggSigMe(publicKey: PublicKey, message: Uint8Array): Program
  createCoin(puzzleHash: Uint8Array, amount: bigint, memos?: Program | undefined | null): Program
  reserveFee(amount: bigint): Program
  createCoinAnnouncement(message: Uint8Array): Program
  createPuzzleAnnouncement(message: Uint8Array): Program
  assertCoinAnnouncement(announcementId: Uint8Array): Program
  assertPuzzleAnnouncement(announcementId: Uint8Array): Program
  assertConcurrentSpend(coinId: Uint8Array): Program
  assertConcurrentPuzzle(puzzleHash: Uint8Array): Program
  assertSecondsRelative(seconds: bigint): Program
  assertSecondsAbsolute(seconds: bigint): Program
  assertHeightRelative(height: number): Program
  assertHeightAbsolute(height: number): Program
  assertBeforeSecondsRelative(seconds: bigint): Program
  assertBeforeSecondsAbsolute(seconds: bigint): Program
  assertBeforeHeightRelative(height: number): Program
  assertBeforeHeightAbsolute(height: number): Program
  assertMyCoinId(coinId: Uint8Array): Program
  assertMyParentId(parentId: Uint8Array): Program
  assertMyPuzzleHash(puzzleHash: Uint8Array): Program
  assertMyAmount(amount: bigint): Program
  assertMyBirthSeconds(seconds: bigint): Program
  assertMyBirthHeight(height: number): Program
  assertEphemeral(): Program
  sendMessage(mode: number, message: Uint8Array, data: Array<Program>): Program
  receiveMessage(mode: number, message: Uint8Array, data: Array<Program>): Program
  softfork(cost: bigint, rest: Program): Program
}

export declare class K1Pair {
  constructor(seed: bigint)
  get sk(): K1SecretKey
  get pk(): K1PublicKey
}

export declare class K1PublicKey {
  static fromBytes(bytes: Uint8Array): K1PublicKey
  toBytes(): Uint8Array
  fingerprint(): number
  verifyPrehashed(prehashed: Uint8Array, signature: K1Signature): boolean
}

export declare class K1SecretKey {
  static fromBytes(bytes: Uint8Array): K1SecretKey
  toBytes(): Uint8Array
  publicKey(): K1PublicKey
  signPrehashed(prehashed: Uint8Array): K1Signature
}

export declare class K1Signature {
  static fromBytes(bytes: Uint8Array): K1Signature
  toBytes(): Uint8Array
}

export declare class Program {
  get isAtom(): boolean
  get isPair(): boolean
  get length(): number
  get first(): Program
  get rest(): Program
  serialize(): Uint8Array
  serializeWithBackrefs(): Uint8Array
  treeHash(): Uint8Array
  toNumber(): number | null
  toBigInt(): bigint | null
  toString(): string | null
  toBool(): boolean | null
  toBytes(): Uint8Array | null
  toPair(): Pair | null
  toList(): Array<Program> | null
  curry(args: Array<Program>): Program
  uncurry(): CurriedProgram | null
  run(solution: Program, maxCost: bigint, mempoolMode: boolean): Output
  puzzle(): Puzzle
  parseRemark(): Remark | null
  parseAggSigParent(): AggSigParent | null
  parseAggSigPuzzle(): AggSigPuzzle | null
  parseAggSigAmount(): AggSigAmount | null
  parseAggSigPuzzleAmount(): AggSigPuzzleAmount | null
  parseAggSigParentAmount(): AggSigParentAmount | null
  parseAggSigParentPuzzle(): AggSigParentPuzzle | null
  parseAggSigUnsafe(): AggSigUnsafe | null
  parseAggSigMe(): AggSigMe | null
  parseCreateCoin(): CreateCoin | null
  parseReserveFee(): ReserveFee | null
  parseCreateCoinAnnouncement(): CreateCoinAnnouncement | null
  parseCreatePuzzleAnnouncement(): CreatePuzzleAnnouncement | null
  parseAssertCoinAnnouncement(): AssertCoinAnnouncement | null
  parseAssertPuzzleAnnouncement(): AssertPuzzleAnnouncement | null
  parseAssertConcurrentSpend(): AssertConcurrentSpend | null
  parseAssertConcurrentPuzzle(): AssertConcurrentPuzzle | null
  parseAssertSecondsRelative(): AssertSecondsRelative | null
  parseAssertSecondsAbsolute(): AssertSecondsAbsolute | null
  parseAssertHeightRelative(): AssertHeightRelative | null
  parseAssertHeightAbsolute(): AssertHeightAbsolute | null
  parseAssertBeforeSecondsRelative(): AssertBeforeSecondsRelative | null
  parseAssertBeforeSecondsAbsolute(): AssertBeforeSecondsAbsolute | null
  parseAssertBeforeHeightRelative(): AssertBeforeHeightRelative | null
  parseAssertBeforeHeightAbsolute(): AssertBeforeHeightAbsolute | null
  parseAssertMyCoinId(): AssertMyCoinId | null
  parseAssertMyParentId(): AssertMyParentId | null
  parseAssertMyPuzzleHash(): AssertMyPuzzleHash | null
  parseAssertMyAmount(): AssertMyAmount | null
  parseAssertMyBirthSeconds(): AssertMyBirthSeconds | null
  parseAssertMyBirthHeight(): AssertMyBirthHeight | null
  parseAssertEphemeral(): AssertEphemeral | null
  parseSendMessage(): SendMessage | null
  parseReceiveMessage(): ReceiveMessage | null
  parseSoftfork(): Softfork | null
}

export declare class PublicKey {
  static infinity(): PublicKey
  static aggregate(publicKeys: Array<PublicKey>): PublicKey
  static fromBytes(bytes: Uint8Array): PublicKey
  toBytes(): Uint8Array
  fingerprint(): number
  isInfinity(): boolean
  isValid(): boolean
  deriveUnhardened(index: number): PublicKey
  deriveUnhardenedPath(path: Array<number>): PublicKey
  deriveSynthetic(): PublicKey
  deriveSyntheticHidden(hiddenPuzzleHash: Uint8Array): PublicKey
}

export declare class Puzzle {
  get puzzleHash(): Uint8Array
  get program(): Program
  get modHash(): Uint8Array
  get args(): Program | null
  parseNft(): NftInfo | null
}

export declare class R1Pair {
  constructor(seed: bigint)
  get sk(): R1SecretKey
  get pk(): R1PublicKey
}

export declare class R1PublicKey {
  static fromBytes(bytes: Uint8Array): R1PublicKey
  toBytes(): Uint8Array
  fingerprint(): number
  verifyPrehashed(prehashed: Uint8Array, signature: R1Signature): boolean
}

export declare class R1SecretKey {
  static fromBytes(bytes: Uint8Array): R1SecretKey
  toBytes(): Uint8Array
  publicKey(): R1PublicKey
  signPrehashed(prehashed: Uint8Array): R1Signature
}

export declare class R1Signature {
  static fromBytes(bytes: Uint8Array): R1Signature
  toBytes(): Uint8Array
}

export declare class SecretKey {
  static fromSeed(seed: Uint8Array): SecretKey
  static fromBytes(bytes: Uint8Array): SecretKey
  toBytes(): Uint8Array
  publicKey(): PublicKey
  sign(message: Uint8Array): Signature
  deriveUnhardened(index: number): SecretKey
  deriveHardened(index: number): SecretKey
  deriveUnhardenedPath(path: Array<number>): SecretKey
  deriveHardenedPath(path: Array<number>): SecretKey
  deriveSynthetic(): SecretKey
  deriveSyntheticHidden(hiddenPuzzleHash: Uint8Array): SecretKey
}

export declare class Signature {
  static infinity(): Signature
  static aggregate(signatures: Array<Signature>): Signature
  static fromBytes(bytes: Uint8Array): Signature
  toBytes(): Uint8Array
  isInfinity(): boolean
  isValid(): boolean
}

export declare class Simulator {
  constructor()
  newCoin(puzzleHash: Uint8Array, amount: bigint): Coin
  bls(amount: bigint): BlsPairWithCoin
  spendCoins(coinSpends: Array<CoinSpend>, secretKeys: Array<SecretKey>): void
}

export interface AddressInfo {
  puzzleHash: Uint8Array
  prefix: string
}

export interface AggSigAmount {
  publicKey: PublicKey
  message: Uint8Array
}

export interface AggSigMe {
  publicKey: PublicKey
  message: Uint8Array
}

export interface AggSigParent {
  publicKey: PublicKey
  message: Uint8Array
}

export interface AggSigParentAmount {
  publicKey: PublicKey
  message: Uint8Array
}

export interface AggSigParentPuzzle {
  publicKey: PublicKey
  message: Uint8Array
}

export interface AggSigPuzzle {
  publicKey: PublicKey
  message: Uint8Array
}

export interface AggSigPuzzleAmount {
  publicKey: PublicKey
  message: Uint8Array
}

export interface AggSigUnsafe {
  publicKey: PublicKey
  message: Uint8Array
}

export interface AssertBeforeHeightAbsolute {
  height: number
}

export interface AssertBeforeHeightRelative {
  height: number
}

export interface AssertBeforeSecondsAbsolute {
  seconds: bigint
}

export interface AssertBeforeSecondsRelative {
  seconds: bigint
}

export interface AssertCoinAnnouncement {
  announcementId: Uint8Array
}

export interface AssertConcurrentPuzzle {
  puzzleHash: Uint8Array
}

export interface AssertConcurrentSpend {
  coinId: Uint8Array
}

export interface AssertEphemeral {

}

export interface AssertHeightAbsolute {
  height: number
}

export interface AssertHeightRelative {
  height: number
}

export interface AssertMyAmount {
  amount: bigint
}

export interface AssertMyBirthHeight {
  height: number
}

export interface AssertMyBirthSeconds {
  seconds: bigint
}

export interface AssertMyCoinId {
  coinId: Uint8Array
}

export interface AssertMyParentId {
  parentId: Uint8Array
}

export interface AssertMyPuzzleHash {
  puzzleHash: Uint8Array
}

export interface AssertPuzzleAnnouncement {
  announcementId: Uint8Array
}

export interface AssertSecondsAbsolute {
  seconds: bigint
}

export interface AssertSecondsRelative {
  seconds: bigint
}

export declare function bytesEqual(lhs: Uint8Array, rhs: Uint8Array): boolean

export interface Cat {
  coin: Coin
  lineageProof?: LineageProof
  assetId: Uint8Array
  p2PuzzleHash: Uint8Array
}

export declare function catPuzzleHash(assetId: Uint8Array, innerPuzzleHash: Uint8Array): Uint8Array

export interface CatSpend {
  cat: Cat
  spend: Spend
}

export interface Coin {
  parentCoinInfo: Uint8Array
  puzzleHash: Uint8Array
  amount: bigint
}

export interface CoinSpend {
  coin: Coin
  puzzleReveal: Uint8Array
  solution: Uint8Array
}

export interface CoinState {
  coin: Coin
  spentHeight?: number
  createdHeight?: number
}

export interface CreateCoin {
  puzzleHash: Uint8Array
  amount: bigint
  memos?: Program
}

export interface CreateCoinAnnouncement {
  message: Uint8Array
}

export interface CreatePuzzleAnnouncement {
  message: Uint8Array
}

export interface CurriedProgram {
  program: Program
  args: Array<Program>
}

export declare function curryTreeHash(program: Uint8Array, args: Array<Uint8Array>): Uint8Array

export declare function decodeAddress(address: string): AddressInfo

export declare function encodeAddress(puzzleHash: Uint8Array, prefix: string): string

export declare function fromHex(value: string): Uint8Array

export declare function generateBytes(bytes: number): Uint8Array

export declare function generateMnemonic(use24: boolean): string

export interface LineageProof {
  parentParentCoinInfo: Uint8Array
  parentInnerPuzzleHash?: Uint8Array
  parentAmount: bigint
}

export declare function mnemonicFromEntropy(entropy: Uint8Array): string

export declare function mnemonicToEntropy(mnemonic: string): Uint8Array

export declare function mnemonicToSeed(mnemonic: string, password: string): Uint8Array

export interface Nft {
  coin: Coin
  lineageProof: LineageProof
  info: NftInfo
}

export interface NftInfo {
  launcherId: Uint8Array
  metadata: Program
  metadataUpdaterPuzzleHash: Uint8Array
  currentOwner?: Uint8Array
  royaltyPuzzleHash: Uint8Array
  royaltyTenThousandths: number
  p2PuzzleHash: Uint8Array
  p2Puzzle?: Program
}

export interface Output {
  value: Program
  cost: bigint
}

export interface Pair {
  first: Program
  rest: Program
}

export interface ReceiveMessage {
  mode: number
  message: Uint8Array
  data: Array<Program>
}

export interface Remark {
  rest: Program
}

export interface ReserveFee {
  amount: bigint
}

export interface SendMessage {
  mode: number
  message: Uint8Array
  data: Array<Program>
}

export declare function sha256(value: Uint8Array): Uint8Array

export interface Softfork {
  cost: bigint
  rest: Program
}

export interface Spend {
  puzzle: Program
  solution: Program
}

export interface SpendBundle {
  coinSpends: Array<CoinSpend>
  aggregatedSignature: Signature
}

export declare function standardPuzzleHash(syntheticKey: PublicKey): Uint8Array

export declare function toCoinId(coin: Coin): Uint8Array

export declare function toHex(value: Uint8Array): string

export declare function treeHashAtom(atom: Uint8Array): Uint8Array

export declare function treeHashPair(first: Uint8Array, rest: Uint8Array): Uint8Array

export declare function verifyMnemonic(mnemonic: string): boolean
