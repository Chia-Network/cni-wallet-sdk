/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class BlsPair {
  constructor(seed: bigint)
  get sk(): SecretKey
  get pk(): PublicKey
}

export declare class BlsPairWithCoin {
  get sk(): SecretKey
  get pk(): PublicKey
  get puzzleHash(): Uint8Array
  get coin(): Coin
}

export declare class Clvm {
  constructor()
  alloc(value: any): Program
  deserialize(value: Uint8Array): Program
  deserializeWithBackrefs(value: Uint8Array): Program
  insertCoinSpend(coinSpend: CoinSpend): void
  coinSpends(): Array<CoinSpend>
  spendCoin(coin: Coin, spend: Spend): void
  delegatedSpend(conditions: Array<Program>): Spend
  standardSpend(syntheticKey: PublicKey, delegatedSpend: Spend): Spend
  spendStandardCoin(coin: Coin, syntheticKey: PublicKey, delegatedSpend: Spend): void
  spendCatCoins(cats: Array<CatSpend>): void
}

export declare class CurriedProgram {
  constructor(program: Program, args: Array<Program>)
  get program(): Program
  get args(): Array<Program>
}

export declare class K1Pair {
  constructor(seed: bigint)
  get sk(): K1SecretKey
  get pk(): K1PublicKey
}

export declare class K1PublicKey {
  static fromBytes(bytes: Uint8Array): K1PublicKey
  toBytes(): Uint8Array
  fingerprint(): number
  verifyPrehashed(prehashed: Uint8Array, signature: K1Signature): boolean
}

export declare class K1SecretKey {
  static fromBytes(bytes: Uint8Array): K1SecretKey
  toBytes(): Uint8Array
  publicKey(): K1PublicKey
  signPrehashed(prehashed: Uint8Array): K1Signature
}

export declare class K1Signature {
  static fromBytes(bytes: Uint8Array): K1Signature
  toBytes(): Uint8Array
}

export declare class Pair {
  constructor(first: Program, second: Program)
  get first(): Program
  get second(): Program
}

export declare class Program {
  get isAtom(): boolean
  get isPair(): boolean
  get length(): number
  get first(): Program
  get rest(): Program
  serialize(): Uint8Array
  serializeWithBackrefs(): Uint8Array
  treeHash(): Uint8Array
  toNumber(): number | null
  toBigInt(): bigint | null
  toString(): string | null
  toBool(): boolean | null
  toAtom(): Uint8Array | null
  toPair(): Pair | null
  toList(): Array<Program> | null
  uncurry(): CurriedProgram | null
  run(solution: Program, maxCost: bigint, mempoolMode: boolean): Output
}

export declare class PublicKey {
  static infinity(): PublicKey
  static aggregate(publicKeys: Array<PublicKey>): PublicKey
  static fromBytes(bytes: Uint8Array): PublicKey
  toBytes(): Uint8Array
  fingerprint(): number
  isInfinity(): boolean
  isValid(): boolean
  deriveUnhardened(index: number): PublicKey
  deriveUnhardenedPath(path: Array<number>): PublicKey
  deriveSynthetic(): PublicKey
  deriveSyntheticHidden(hiddenPuzzleHash: Uint8Array): PublicKey
}

export declare class R1Pair {
  constructor(seed: bigint)
  get sk(): R1SecretKey
  get pk(): R1PublicKey
}

export declare class R1PublicKey {
  static fromBytes(bytes: Uint8Array): R1PublicKey
  toBytes(): Uint8Array
  fingerprint(): number
  verifyPrehashed(prehashed: Uint8Array, signature: R1Signature): boolean
}

export declare class R1SecretKey {
  static fromBytes(bytes: Uint8Array): R1SecretKey
  toBytes(): Uint8Array
  publicKey(): R1PublicKey
  signPrehashed(prehashed: Uint8Array): R1Signature
}

export declare class R1Signature {
  static fromBytes(bytes: Uint8Array): R1Signature
  toBytes(): Uint8Array
}

export declare class SecretKey {
  static fromSeed(seed: Uint8Array): SecretKey
  static fromBytes(bytes: Uint8Array): SecretKey
  toBytes(): Uint8Array
  publicKey(): PublicKey
  sign(message: Uint8Array): Signature
  deriveUnhardened(index: number): SecretKey
  deriveHardened(index: number): SecretKey
  deriveUnhardenedPath(path: Array<number>): SecretKey
  deriveHardenedPath(path: Array<number>): SecretKey
  deriveSynthetic(): SecretKey
  deriveSyntheticHidden(hiddenPuzzleHash: Uint8Array): SecretKey
}

export declare class Signature {
  static infinity(): Signature
  static aggregate(signatures: Array<Signature>): Signature
  static fromBytes(bytes: Uint8Array): Signature
  toBytes(): Uint8Array
  isInfinity(): boolean
  isValid(): boolean
}

export declare class Simulator {
  constructor()
  newCoin(puzzleHash: Uint8Array, amount: bigint): Coin
  bls(amount: bigint): BlsPairWithCoin
  spendCoins(coinSpends: Array<CoinSpend>, secretKeys: Array<SecretKey>): void
}

export interface AddressInfo {
  puzzleHash: Uint8Array
  prefix: string
}

export declare function bytesEqual(lhs: Uint8Array, rhs: Uint8Array): boolean

export interface Cat {
  coin: Coin
  lineageProof?: LineageProof
  assetId: Uint8Array
  p2PuzzleHash: Uint8Array
}

export declare function catPuzzleHash(assetId: Uint8Array, innerPuzzleHash: Uint8Array): Uint8Array

export interface CatSpend {
  cat: Cat
  spend: Spend
}

export interface Coin {
  parentCoinInfo: Uint8Array
  puzzleHash: Uint8Array
  amount: bigint
}

export interface CoinSpend {
  coin: Coin
  puzzleReveal: Uint8Array
  solution: Uint8Array
}

export interface CoinState {
  coin: Coin
  spentHeight?: number
  createdHeight?: number
}

export declare function curryTreeHash(program: Uint8Array, args: Array<Uint8Array>): Uint8Array

export declare function decodeAddress(address: string): AddressInfo

export declare function encodeAddress(puzzleHash: Uint8Array, prefix: string): string

export declare function fromHex(value: string): Uint8Array

export declare function generateBytes(bytes: number): Uint8Array

export declare function generateMnemonic(use24: boolean): string

export interface LineageProof {
  parentParentCoinInfo: Uint8Array
  parentInnerPuzzleHash?: Uint8Array
  parentAmount: bigint
}

export declare function mnemonicFromEntropy(entropy: Uint8Array): string

export declare function mnemonicToEntropy(mnemonic: string): Uint8Array

export declare function mnemonicToSeed(mnemonic: string, password: string): Uint8Array

export interface Output {
  value: Program
  cost: bigint
}

export declare function sha256(value: Uint8Array): Uint8Array

export interface Spend {
  puzzle: Program
  solution: Program
}

export interface SpendBundle {
  coinSpends: Array<CoinSpend>
  aggregatedSignature: Signature
}

export declare function standardPuzzleHash(syntheticKey: PublicKey): Uint8Array

export declare function toHex(value: Uint8Array): string

export declare function treeHashAtom(atom: Uint8Array): Uint8Array

export declare function treeHashPair(first: Uint8Array, rest: Uint8Array): Uint8Array

export declare function verifyMnemonic(mnemonic: string): boolean
